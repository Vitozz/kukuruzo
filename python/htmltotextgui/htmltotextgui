#!/usr/bin/env python
#-*- coding: utf-8 -*-

import pygtk
pygtk.require('2.0')
import gtk
import gtk.glade
import os, re, string, threading, thread, HTMLParser
gtk.gdk.threads_init()
try:
    import chardet
    from chardet.universaldetector import UniversalDetector
except:
    os.sys.stderr.write("Error! No Module python-chardet found.")

class MLStripper(HTMLParser.HTMLParser):
    def __init__(self):
        self.reset()
        self.fed = []
    def handle_data(self, d):
        self.fed.append(d)
    def get_fed_data(self):
        return ''.join(self.fed)

class mainForm:
    def __init__(self):
        self.files = []
        self.done = False
        self.ismanual = False
        self.txtencoding = ""
        self.htmlencoding = ""
        self.job = None
        self.isError = False
        self.wasError = False
        self.tags = re.compile(r'<[^<]*?/?>', re.IGNORECASE)
        self.adtag = re.compile(r'<[^<]*?/?>|(?:&.*?;)', re.IGNORECASE)
        self.empty = re.compile(r'^(?:\s)*$', re.MULTILINE)
        self.filter = gtk.FileFilter()
        self.filter.add_pattern("*.html")
        self.filter.add_pattern("*.htm")
        if str(os.sys.platform) == 'win32':
            gladefile = 'main_win.glade'
        else:
            gladefile = '/usr/share/htmltotextgui/main.glade'
        self.wTree = gtk.glade.XML(gladefile)
        dic = {"on_mainForm_destroy_event": self.OnDestroy, "on_mainForm_delete_event": self.OnDestroy,
               "on_filechooser_selection_changed": self.OnFile, "on_runit_pressed":self.OnRun,
               "on_charselect_changed": self.OnCharSelect,  "on_automat_toggled": self.OnAutomat,
               "on_manual_toggled":self.OnManual, "on_htmlchar_changed": self.OnHtmlChar }
        self.wTree.signal_autoconnect(dic)
        self.mainForm = self.wTree.get_widget("mainForm")
        self.charselect = self.wTree.get_widget("charselect")
        self.htmlchar = self.wTree.get_widget("htmlchar")
        self.charselect.set_active(0)
        self.htmlchar.set_active(0)
        self.progress = self.wTree.get_widget("progress")
        self.automat = self.wTree.get_widget("automat")
        self.manual = self.wTree.get_widget("manual")
        self.automat.toggled()
        self.filechooser = self.wTree.get_widget("filechooser")
        self.filechooser.set_filter(self.filter)
        self.button = self.wTree.get_widget("runit")
        self.sens_objects = (self.automat, self.manual, self.filechooser, self.charselect, self.button)
        self.mainForm.show_all()

    def OnAutomat(self,  widget):
        if widget.get_active():
            self.htmlchar.set_sensitive(False)
            self.ismanual = False

    def OnManual(self,  widget):
        if widget.get_active():
            self.htmlchar.set_sensitive(True)
            self.ismanual = True

    def OnHtmlChar(self,  widget) :
        self.htmlencoding = widget.get_active_text()

    def OnFile(self, widget):
        self.files = []
        self.files = widget.get_filenames()

    def OnRun(self, widget):
        for i in self.sens_objects:
            if i != None:
                i.set_sensitive(False)
        self.WalkOn()

    def OnCharSelect(self, widget):
        self.txtencoding = widget.get_active_text()

    def OnDestroy(self, widget, event):
        gtk.main_quit()
        return True

    def SetText(self, index, total, text):
        value = float(index)/float(total)
        self.progress.set_fraction(value)
        self.progress.set_text(text)
        while gtk.events_pending():
            gtk.main_iteration()


    def RemoveTAGS(self, text, htmlfile, enc):
        try:
            tmp1 = MLStripper()
            tmp1.feed(text)
            tmp2 = tmp1.get_fed_data()
            tmp3 = self.tags.sub('',  tmp2)
            self.isError = False
            return self.RemoveEmptyLines(tmp3, enc)
        except HTMLParser.HTMLParseError, msg:
            self.isError = True
            error = str(msg) + "\nin file:\n" + str(htmlfile)
            if str(os.sys.platform) != 'win32':
                os.sys.stderr.write(str(error))
            self.on_info("Ошибка модуля HTMLParser. Неверный тег\n%s\n\nТеги будут удалены при помощи регулярных выражений\nВ TXT файле возможен мусор"%error)
            tmp4 = self.adtag.sub('',text)
            return self.RemoveEmptyLines(tmp4, enc)

    def RemoveEmptyLines(self, text, enc):
        lines = string.split(text, '\n')
        result = []
        for line in lines:
            if line.strip():
                if self.empty.search(line):
                    continue
                else:
                    if ord(line[-1:]) == 13:
                        result.append(line.encode(enc))
                    else:
                        result.append((line+'\n').encode(enc))
        return result

    def WalkOn(self):
        for i in self.sens_objects:
            if i != None:
                i.set_sensitive(False)
        files = self.files
        outencoding = self.txtencoding
        encoding = ""
        if files:
            for item in files:
                if item != None:
                    new_lines = []
                    lines = []
                    enc_lines = ""
                    outtext = []
                    lines = self.readFile(item)
                    if not self.ismanual:
                        encoding = self.Decode(lines)
                        if encoding == 'MacCyrillic':
                            encoding = 'windows-1251'
                        print encoding
                    else:
                        encoding = self.htmlencoding
                    enc_lines = "".join(lines).decode(encoding)
                    self.SetText(files.index(item), len(files), "Converting file %s..."%item)
                    txtfile = self.GetFilename(item) + "txt"
                    outtext = self.RemoveTAGS(enc_lines, item, outencoding)
                    if self.isError:
                        self.wasError = True
                    if str(os.sys.platform) == 'win32':
                        txtfile = txtfile.decode('UTF-8')
                    fl = open(txtfile, "w")
                    fl.seek(0)
                    fl.writelines(outtext)
                    fl.close()
                    self.done = True
            if self.done:
                self.SetText(1,1,"Job Finished!")
                if self.wasError:
                    self.on_info("Job Finished With Errors")
                else:
                    self.on_info("Job Finished")

    def readFile(self, filename):
        result = []
        if str(os.sys.platform) == 'win32':
            filename = filename.decode('UTF-8')
        f = open(filename, "rb")
        f.seek(0)
        for line in f.readlines():
            if line:
                result.append(line)
        f.close()
        return result

    def on_info(self, text):
        md = gtk.MessageDialog(None,
            gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO,
            gtk.BUTTONS_CLOSE, text)
        md.run()
        md.destroy()
        if text == "Job Finished":
            self.SetText(0,1,"0%")
            for i in self.sens_objects:
                if i != None:
                    i.set_sensitive(True)

    def GetFilename(self, htmlfile):
        if htmlfile:
            if htmlfile[-4:] == "html":
                if htmlfile[-5] == ".":
                    return htmlfile[0: len(htmlfile)-4]
            elif htmlfile[-3:] == "htm":
                if htmlfile[-4] == ".":
                    return htmlfile[0: len(htmlfile)-3]
            else:
                return ""
        else:
            return ""

    def Decode(self, lines):
        detector = UniversalDetector()
        for line in lines:
            detector.feed(line)
            if detector.done: break
        detector.close()
        tmp = detector.result
        result = tmp['encoding']
        return result

if __name__ == "__main__":
    app = mainForm()
    gtk.gdk.threads_enter()
    gtk.main()
    gtk.gdk.threads_leave()
